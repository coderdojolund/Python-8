# Snake ‚≠ê‚≠ê‚≠ê
## En handledning f√∂r Python och Pygame Zero 1.2

**[Regler](#regler)**

**[√ñversikt](#√∂versikt)**

**[Kodning](#kodning)**
  [Rita bakgrunden](#rita-bakgrunden)
  &bull; [Rita ormen](#rita-ormen)
  &bull; [Timer](#timer)
  &bull; [Flytta ormen √•t h√∂ger](#flytta-ormen-√•t-h√∂ger)
  &bull; [Flytta ormen i alla fyra riktningar](#flytta-ormen-i-alla-fyra-riktningar)
  &bull; [Hindra att ormen r√∂r sig rakt bak√•t](#hindra-att-ormen-r√∂r-sig-rakt-bak√•t)
  &bull; [Anv√§nd en k√∂ f√∂r riktningarna](#anv√§nd-en-k√∂-f√∂r-riktningarna)
  &bull; [Hindra att l√§gga till samma riktning tv√• g√•nger](#hindra-att-l√§gga-till-samma-riktning-tv√•-g√•nger)
  &bull; [Sl√• √∂ver vid sk√§rmkanten](#sl√•-√∂ver-vid-sk√§rmkanten)
  &bull; [Rita maten](#rita-maten)
  &bull; [F√∂renkla koden](#f√∂renkla-koden)
  &bull; [√Ñta maten](#√§ta-maten)
  &bull; [F√∂renkla koden](#f√∂renkla-koden-1)
  &bull; [Flytta maten till en ledig ruta](#flytta-maten-till-en-ledig-ruta)
  &bull; [Game over](#game-over)
  &bull; [√Öterst√§lla spelet](#√•terst√§lla-spelet)
  &bull; [Pausa efter att ormen har kraschat](#pausa-efter-att-ormen-har-kraschat)
  &bull; [√Ñndra ormens f√§rg n√§r den √§r d√∂d](#√§ndra-ormens-f√§rg-n√§r-den-√§r-d√∂d)

**[Uppgifter](#uppgifter)**

**[K√§llor](#k√§llor)**

![image](https://user-images.githubusercontent.com/4598641/226439115-c9800ff9-c916-406c-9efb-39407658988a.png)

‚úèÔ∏è Pennan visar n√•got du ska g√∂ra. Mata in koden och testk√∂r innan du g√•r vidare. 
**Fungerar det inte? R√§tta koden innan du forts√§tter till n√§sta √§ndring.**

# Regler
N√§r ormen √§ter mat, v√§xer den. N√§r en matbit √§r upp√§ten, dyker det upp en ny p√• en slumpm√§ssig position.

Ormen kommer att sl√• √∂ver till andra sidan sk√§rmen n√§r den g√•r utanf√∂r kanten.

Spelet √§r √∂ver n√§r ormen slingrar in i sig sj√§lv.

## Kontroller
**Piltangenter**	Byt riktning

# √ñversikt
Ormen representeras av en sekvens av X- och Y-koordinater.

Maten representeras av en X- och Y-koordinat.

N√§r ormen r√∂r sig, tas det sista elementet i sekvensen, allts√• den gamla svanspositionen, bort.
Ett nytt element l√§ggs till f√∂rst i sekvensen. Det √§r den nya positionen f√∂r huvudet i den riktning som ormen ringlar.

![image](https://user-images.githubusercontent.com/4598641/226439258-020b4582-5409-448b-99e6-55cf6a4bbcdc.png)

![image](https://user-images.githubusercontent.com/4598641/226439284-599e5e4f-6987-4eea-8b79-f39d5a2d850a.png)

Om den nya huvudpositionen √§r i samma position som matens position tas inte ormens svans bort och maten flyttas till en slumpm√§ssig position som inte upptas av ormen.

![image](https://user-images.githubusercontent.com/4598641/226439323-b54bc813-62f2-49d5-ac3b-1002ba0de713.png)

Om den nya huvudpositionen √§r i samma position som n√•gon av ormens andra segment, √§r spelet √∂ver.

# Kodning
## Rita bakgrunden
Spelomr√•det √§r 20 celler brett och 15 celler h√∂gt, och varje cell har en sidol√§ngd p√• 15 pixlar.

En rektangel ritas f√∂r bakgrunden.

‚úèÔ∏è Se till att du √§r inloggad i repl.it. √ñppna startprojektet https://replit.com/@RobertStorlind/snake-starter och spara en egen kopia med knappen "Fork".

‚úèÔ∏è K√∂r koden med Run i repl.it. Ser det ut s√• h√§r?

![image](https://user-images.githubusercontent.com/4598641/235364441-4af78ea9-4545-40d5-af52-ed10b6de87da.png)

<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun
from pygame import Rect

# Globala variabler h√§r nedanf√∂r

# Funktioner h√§r nedanf√∂r
def draw():
    screen.fill((0, 0, 0))
    
    grid_x_count = 20
    grid_y_count = 15
    cell_size = 15
    
    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70)
    )
  
# Kod f√∂r att starta appen h√§r nedanf√∂r

pgzrun.go() # m√•ste vara sista raden
```
</details>

## Rita ormen
Ormens segment lagras som X- och Y-koordinater och ritas som rutor.

‚úèÔ∏è Uppdatera funktionen `draw` och testk√∂r! Ritas ormen r√§tt?
>Raderna som ska √§ndras √§r markerade med üêç

```python
import pgzrun

# Globala variabler h√§r nedanf√∂r

# Funktioner h√§r nedanf√∂r
def draw():
    screen.fill((0, 0, 0))

    grid_x_count = 20
    grid_y_count = 15
    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    snake_segments = [ #nytt üêç
        {'x': 2, 'y': 0}, #nytt üêç
        {'x': 1, 'y': 0}, #nytt üêç 
        {'x': 0, 'y': 0}, #nytt üêç
    ] #nytt üêç

    for segment in snake_segments: #nytt üêç
        screen.draw.filled_rect( #nytt üêç
            Rect( #nytt üêç
                segment['x'] * cell_size, segment['y'] * cell_size, #nytt üêç
                cell_size - 1, cell_size - 1 #nytt üêç
            ), #nytt üêç
            color=(165, 255, 81) #nytt üêç
        ) #nytt üêç

# Kod f√∂r att starta appen h√§r nedanf√∂r

pgzrun.go()  # m√•ste vara sista raden
```

‚úèÔ∏è Testk√∂r koden. S√• h√§r ska det se ut.
>Fungerar det inte? Kolla dina √§ndringar noga.

![image](https://user-images.githubusercontent.com/4598641/226439469-a0bf9621-d2ff-4b38-810e-9a1be63b3324.png)


## Timer
Ormen kommer att r√∂ra sig var 0,15:e sekund.

En timervariabel b√∂rjar p√• 0 och √∂kar med `dt` f√∂r varje bildruta.

N√§r timern √§r st√∂rre eller lika med 0,15 √•terst√§lls den till 0.

F√∂r n√§rvarande skrivs 'tick' ut varje g√•ng ormen ska r√∂ra sig.

‚úèÔ∏è Uppdatera koden. Testk√∂r och kolla utskriften i terminalf√∂nstret.

```python
import pgzrun

# Globala variabler h√§r nedanf√∂r
timer = 0 #nytt üêç

# Funktioner h√§r nedanf√∂r
def update(dt): #nytt üêç
    global timer #nytt üêç
    
    timer += dt #nytt üêç
    if timer >= 0.15: #nytt üêç
        timer = 0 #nytt üêç
        # Tillf√§lligt #nytt üêç
        print('tick') #nytt üêç

# etc.
```
‚úèÔ∏è Testk√∂r och kolla utskriften i terminalf√∂nstret. Ser det ut s√• h√§r?

![image](https://user-images.githubusercontent.com/4598641/235365117-32e6a3e4-1427-450b-8f0b-8fddb4fb64ee.png)


<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun

# Globala variabler h√§r nedanf√∂r
timer = 0

# Funktioner h√§r nedanf√∂r


def update(dt):
    global timer

    timer += dt
    if timer >= 0.15:
        timer = 0
        # Temporary
        print("tick")


def draw():
    screen.fill((0, 0, 0))

    grid_x_count = 20
    grid_y_count = 15
    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    snake_segments = [
        {"x": 2, "y": 0},
        {"x": 1, "y": 0},
        {"x": 0, "y": 0},
    ]

    for segment in snake_segments:
        screen.draw.filled_rect(
            Rect(
                segment["x"] * cell_size,
                segment["y"] * cell_size,
                cell_size - 1,
                cell_size - 1,
            ),
            color=(165, 255, 81),
        )


# Kod f√∂r att starta appen h√§r nedanf√∂r

pgzrun.go()  # m√•ste vara sista raden
```

</details>

## Flytta ormen √•t h√∂ger
N√§sta position f√∂r ormens huvud ber√§knas genom att √∂ka  den nuvarande X-koordinaten f√∂r ormens huvud med 1. Det √§r f√∂rsta elementet i listan med ormens segment.
Detta nya segment l√§ggs till i b√∂rjan av segmentlistan.

Det sista elementet i segmentlistan, ormens svans, tas bort.

Segmentlistan √§ndras i funktionen `update()`, s√• den flyttas till att vara global.

‚úèÔ∏è Uppdatera koden och testk√∂r.

```python
import pgzrun

# Globala variabler h√§r nedanf√∂r
snake_segments = [ #flyttad fr√•n funktionen draw() üêç
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

# Funktioner h√§r nedanf√∂r
def update(dt):
    global timer

    timer += dt
    if timer >= 0.15:
        timer = 0
        next_x_position = snake_segments[0]['x'] + 1  #nytt üêç
        next_y_position = snake_segments[0]['y']  #nytt üêç

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position}) #nytt üêç
        snake_segments.pop() #nytt üêç


def draw():
    screen.fill((0, 0, 0))

    grid_x_count = 20
    grid_y_count = 15
    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    # snake_segments har flyttat üêç

    for segment in snake_segments:
    # etc.
```
‚úèÔ∏è Testk√∂r! Flyttar ormen i X-led?

![image](https://user-images.githubusercontent.com/4598641/226439549-4395b5df-c7f0-4a1f-9a91-921994eb1365.png)

<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun

# Globala variabler h√§r nedanf√∂r
snake_segments = [
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

# Funktioner h√§r nedanf√∂r

def update(dt):
    global timer

    timer += dt
    if timer >= 0.15:
        timer = 0
        next_x_position = snake_segments[0]['x'] + 1
        next_y_position = snake_segments[0]['y']

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})
        snake_segments.pop()


def draw():
    screen.fill((0, 0, 0))

    grid_x_count = 20
    grid_y_count = 15
    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )
  
    for segment in snake_segments:
        screen.draw.filled_rect(
            Rect(
                segment['x'] * cell_size, segment['y'] * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=(165, 255, 81)
        )

# Kod f√∂r att starta appen h√§r nedanf√∂r

pgzrun.go()  # m√•ste vara sista raden
```
</details>

## Flytta ormen i alla fyra riktningar
Ormens nuvarande riktning lagras i en variabel och √§ndras med hj√§lp av piltangenterna.

Ormens n√§sta huvudposition ska st√§llas in beroende p√• denna riktning.

‚úèÔ∏è Uppdatera koden s√• h√§r. Testk√∂r med piltangenterna.
>Kom ih√•g att f√∂rst klicka i spelf√∂nstret s√• kan din kod f√•nga upp tangenterna.

```python
import pgzrun

# Globala variabler h√§r nedanf√∂r
snake_segments = [
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

direction = 'right' #nytt üêç

# Funktioner h√§r nedanf√∂r

def update(dt):
    global timer

    timer += dt
    if timer >= 0.15:
        timer = 0
        next_x_position = snake_segments[0]['x'] #nytt üêç
        next_y_position = snake_segments[0]['y']

        if direction == 'right': #nytt üêç
            next_x_position += 1 #nytt üêç
        elif direction == 'left': #nytt üêç
            next_x_position -= 1 #nytt üêç
        elif direction == 'down': #nytt üêç
            next_y_position += 1 #nytt üêç
        elif direction == 'up': #nytt üêç
            next_y_position -= 1 #nytt üêç

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})
        snake_segments.pop()

def on_key_down(key): #nytt üêç
    global direction #nytt üêç

    if key == keys.RIGHT: #nytt üêç
        direction = 'right' #nytt üêç
    elif key == keys.LEFT: #nytt üêç
        direction = 'left' #nytt üêç
    elif key == keys.DOWN: #nytt üêç
        direction = 'down' #nytt üêç
    elif key == keys.UP: #nytt üêç
        direction = 'up' #nytt üêç

# etc.
```

‚úèÔ∏è Testk√∂r med piltangenterna.

![image](https://user-images.githubusercontent.com/4598641/226439597-2d0fded6-4174-4bbb-8dc1-9f3499761701.png)

<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun

# Globala variabler h√§r nedanf√∂r
snake_segments = [
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

direction = 'right'

# Funktioner h√§r nedanf√∂r

def update(dt):
    global timer

    timer += dt
    if timer >= 0.15:
        timer = 0
        next_x_position = snake_segments[0]['x']
        next_y_position = snake_segments[0]['y']

        if direction == 'right':
            next_x_position += 1
        elif direction == 'left':
            next_x_position -= 1
        elif direction == 'down':
            next_y_position += 1
        elif direction == 'up':
            next_y_position -= 1

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})
        snake_segments.pop()


def on_key_down(key):
    global direction

    if key == keys.RIGHT:
        direction = 'right'
    elif key == keys.LEFT:
        direction = 'left'
    elif key == keys.DOWN:
        direction = 'down'
    elif key == keys.UP:
        direction = 'up'


def draw():
    screen.fill((0, 0, 0))

    grid_x_count = 20
    grid_y_count = 15
    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    for segment in snake_segments:
        screen.draw.filled_rect(
            Rect(
                segment['x'] * cell_size, segment['y'] * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=(165, 255, 81)
        )

# Kod f√∂r att starta appen h√§r nedanf√∂r

pgzrun.go()  # m√•ste vara sista raden
```
    
</details>

## Hindra att ormen r√∂r sig rakt bak√•t
Ormen ska inte kunna r√∂ra sig i motsatt riktning som den f√∂r n√§rvarande g√•r. N√§r den t.ex. g√•r √•t h√∂ger ska den inte direkt g√• √•t v√§nster. Detta kontrolleras innan riktningen st√§lls in.

‚úèÔ∏è Uppdatera funktionen `on_key_down()`. 

```python
def on_key_down(key):
    global direction

    if key == keys.RIGHT and direction != 'left': #√§ndrat üêç
        direction = 'right'
    elif key == keys.LEFT and direction != 'right': #√§ndrat üêç
        direction = 'left'
    elif key == keys.DOWN and direction != 'up': #√§ndrat üêç
        direction = 'down'
    elif key == keys.UP and direction != 'down': #√§ndrat üêç
        direction = 'up'
```

‚úèÔ∏è Testk√∂r sv√§ngar med piltangenterna och kolla om det blev r√§tt!

<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun

# Globala variabler h√§r nedanf√∂r
snake_segments = [
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

direction = 'right'

# Funktioner h√§r nedanf√∂r


def update(dt):
    global timer

    timer += dt
    if timer >= 0.15:
        timer = 0
        next_x_position = snake_segments[0]['x']
        next_y_position = snake_segments[0]['y']

        if direction == 'right':
            next_x_position += 1
        elif direction == 'left':
            next_x_position -= 1
        elif direction == 'down':
            next_y_position += 1
        elif direction == 'up':
            next_y_position -= 1

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})
        snake_segments.pop()


def on_key_down(key):
    global direction

    if key == keys.RIGHT and direction != 'left':
        direction = 'right'
    elif key == keys.LEFT and direction != 'right':
        direction = 'left'
    elif key == keys.DOWN and direction != 'up':
        direction = 'down'
    elif key == keys.UP and direction != 'down':
        direction = 'up'


def draw():
    screen.fill((0, 0, 0))

    grid_x_count = 20
    grid_y_count = 15
    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )
  
    for segment in snake_segments:
        screen.draw.filled_rect(
            Rect(
                segment['x'] * cell_size, segment['y'] * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=(165, 255, 81)
        )

# Kod f√∂r att starta appen h√§r nedanf√∂r


pgzrun.go()  # m√•ste vara sista raden
```
    
</details>

## Anv√§nd en k√∂ f√∂r riktningarna
Just nu kan ormen fortfarande g√• bak√•t om en annan riktning och sedan den motsatta riktningen trycks inom ett enda tick p√• timern.
Om ormen t.ex. slingrade √•t h√∂ger p√• den sista ticket och du trycker ner√•tpil och sedan v√§nsterpil f√∂re n√§sta tick, kommer ormen att flytta √•t v√§nster p√• n√§sta tick.

Dessutom kan spelaren vilja ge flera anvisningar inom ett enda tick. I exemplet ovan kan spelaren ha velat att ormen skulle flytta ner√•t ett tick och sen v√§nster n√§sta tick.

D√§rf√∂r beh√∂ver vi en riktningsk√∂. Det f√∂rsta elementet i k√∂n √§r riktningen som ormen kommer att r√∂ra sig vid n√§sta tick.

Om  riktningsk√∂n har mer √§n ett element, tas det f√∂rsta elementet bort vid varje tick.

N√§r en knapp trycks ned l√§ggs riktningen till i slutet av riktningsk√∂n.

Det sista elementet i riktningsk√∂n, allts√• den senast tryckta riktningen, kontrolleras f√∂r att se om att inte √§r i motsatt riktning mot den nya riktningen innan den nya riktningen l√§ggs till i riktningsk√∂n.

‚úèÔ∏è Uppdatera koden.

```python
import pgzrun

# Globala variabler h√§r nedanf√∂r
snake_segments = [
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

direction_queue = ['right'] #√§ndrat üêç

# Funktioner h√§r nedanf√∂r
def update(dt):
    global timer

    timer += dt
    if timer >= 0.15:
        timer = 0
        if len(direction_queue) > 1: #nytt üêç
            direction_queue.pop(0) #nytt üêç

        next_x_position = snake_segments[0]['x']
        next_y_position = snake_segments[0]['y']

        if direction_queue[0] == 'right': #√§ndrat üêç
            next_x_position += 1
        elif direction_queue[0] == 'left': #√§ndrat üêç
            next_x_position -= 1
        elif direction_queue[0] == 'down': #√§ndrat üêç
            next_y_position += 1
        elif direction_queue[0] == 'up': #√§ndrat üêç
            next_y_position -= 1

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})
        snake_segments.pop()


def on_key_down(key):
    if (key == keys.RIGHT and direction_queue[-1] != 'left'): #√§ndrat üêç
        direction_queue.append('right') #nytt üêç

    elif (key == keys.LEFT and direction_queue[-1] != 'right'): #√§ndrat üêç
        direction_queue.append('left') #nytt üêç

    elif (key == keys.DOWN and direction_queue[-1] != 'up'): #√§ndrat üêç
        direction_queue.append('down') #nytt üêç

    elif (key == keys.UP #√§ndrat üêç
          and direction_queue[-1] != 'down'): #√§ndrat üêç
        direction_queue.append('up') #nytt üêç


def draw():
    screen.fill((0, 0, 0))

    grid_x_count = 20
    grid_y_count = 15
    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )
    
    for segment in snake_segments:
        screen.draw.filled_rect(
            Rect(
                segment['x'] * cell_size, segment['y'] * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=(165, 255, 81)
        )

    # Tillf√§lligt #nytt üêç
    for direction_index, direction in enumerate(direction_queue): #nytt üêç
        screen.draw.text( #nytt üêç
            f"direction_queue[{direction_index}]: {direction}", #nytt üêç
            (15, 15 + 15 * direction_index)) #nytt üêç

# Kod f√∂r att starta appen h√§r nedanf√∂r
pgzrun.go()  # m√•ste vara sista raden

```
‚úèÔ∏è Testk√∂r &ndash; vad h√§nder n√§r du trycker snabbt p√• de olika piltangenterna?

![image](https://user-images.githubusercontent.com/4598641/226439688-1765d719-ee76-4b94-be2f-d8760ced80d7.png)

<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun

# Globala variabler h√§r nedanf√∂r
snake_segments = [
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

direction_queue = ['right']

# Funktioner h√§r nedanf√∂r


def update(dt):
    global timer

    timer += dt
    if timer >= 0.15:
        timer = 0
        if len(direction_queue) > 1:
            direction_queue.pop(0)

        next_x_position = snake_segments[0]['x']
        next_y_position = snake_segments[0]['y']

        if direction_queue[0] == 'right':
            next_x_position += 1
        elif direction_queue[0] == 'left':
            next_x_position -= 1
        elif direction_queue[0] == 'down':
            next_y_position += 1
        elif direction_queue[0] == 'up':
            next_y_position -= 1

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})
        snake_segments.pop()


def on_key_down(key):
    if (key == keys.RIGHT
            and direction_queue[-1] != 'left'):
        direction_queue.append('right')

    elif (key == keys.LEFT
          and direction_queue[-1] != 'right'):
        direction_queue.append('left')

    elif (key == keys.DOWN
          and direction_queue[-1] != 'up'):
        direction_queue.append('down')

    elif (key == keys.UP
          and direction_queue[-1] != 'down'):
        direction_queue.append('up')


def draw():
    screen.fill((0, 0, 0))

    grid_x_count = 20
    grid_y_count = 15
    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    for segment in snake_segments:
        screen.draw.filled_rect(
            Rect(
                segment['x'] * cell_size, segment['y'] * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=(165, 255, 81)
        )

    # Tillf√§lligt
    for direction_index, direction in enumerate(direction_queue):
        screen.draw.text(
            f"direction_queue[{direction_index}]: {direction}",
            (15, 15 + 15 * direction_index))

# Kod f√∂r att starta appen h√§r nedanf√∂r


pgzrun.go()  # m√•ste vara sista raden
```
</details>

## Hindra att l√§gga till samma riktning tv√• g√•nger
Om den senaste riktningen √§r samma som den nya riktningen, ska den nya riktningen inte l√§ggas till i riktningsk√∂n.

‚úèÔ∏è Uppdaterad üêç-raderna i `on_key_down()`. 

```python
def on_key_down(key):
    if (key == keys.RIGHT
        and direction_queue[-1] != 'right' #nytt üêç
        and direction_queue[-1] != 'left'):
        direction_queue.append('right')

    elif (key == keys.LEFT
          and direction_queue[-1] != 'left' #nytt üêç
          and direction_queue[-1] != 'right'):
        direction_queue.append('left')

    elif (key == keys.DOWN
          and direction_queue[-1] != 'down' #nytt üêç
          and direction_queue[-1] != 'up'):
        direction_queue.append('down')

    elif (key == keys.UP
          and direction_queue[-1] != 'up' #nytt üêç
          and direction_queue[-1] != 'down'):
        direction_queue.append('up')
```

Testk√∂r &ndash; vad h√§nder n√§r du  snabbt trycker p√• olika piltangenter, eller samma piltangent?

<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun

# Globala variabler h√§r nedanf√∂r
snake_segments = [
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

direction_queue = ['right']

# Funktioner h√§r nedanf√∂r

def update(dt):
    global timer

    timer += dt
    if timer >= 0.15:
        timer = 0
        if len(direction_queue) > 1:
            direction_queue.pop(0)

        next_x_position = snake_segments[0]['x']
        next_y_position = snake_segments[0]['y']

        if direction_queue[0] == 'right':
            next_x_position += 1
        elif direction_queue[0] == 'left':
            next_x_position -= 1
        elif direction_queue[0] == 'down':
            next_y_position += 1
        elif direction_queue[0] == 'up':
            next_y_position -= 1

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})
        snake_segments.pop()


def on_key_down(key):
    if (key == keys.RIGHT
        and direction_queue[-1] != 'right'
        and direction_queue[-1] != 'left'):
        direction_queue.append('right')

    elif (key == keys.LEFT
          and direction_queue[-1] != 'left'
          and direction_queue[-1] != 'right'):
        direction_queue.append('left')

    elif (key == keys.DOWN
          and direction_queue[-1] != 'down'
          and direction_queue[-1] != 'up'):
        direction_queue.append('down')

    elif (key == keys.UP
          and direction_queue[-1] != 'up'
          and direction_queue[-1] != 'down'):
        direction_queue.append('up')


def draw():
    screen.fill((0, 0, 0))

    grid_x_count = 20
    grid_y_count = 15
    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    for segment in snake_segments:
        screen.draw.filled_rect(
            Rect(
                segment['x'] * cell_size, segment['y'] * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=(165, 255, 81)
        )

    # Tillf√§lligt
    for direction_index, direction in enumerate(direction_queue):
        screen.draw.text(
            f"direction_queue[{direction_index}]: {direction}",
            (15, 15 + 15 * direction_index))

# Kod f√∂r att starta appen h√§r nedanf√∂r


pgzrun.go()  # m√•ste vara sista raden    
```
</details>

## Sl√• √∂ver vid sk√§rmkanten
Om n√§sta position skulle vara utanf√∂r rutn√§tet, sl√•r vi √∂ver till motsatta sidan p√• sk√§rmen.

Rutn√§tets X/Y-storlek √•teranv√§nds fr√•n att rita bakgrunden, s√• de variablerna flyttas till att vara globala.

‚úèÔ∏è Uppdatera/flytta raderna med üêç s√• att det blir s√• h√§r:

```python
# etc.

grid_x_count = 20 #flyttad üêç
grid_y_count = 15 #flyttad üêç

def update(dt):
    # etc.

        if direction_queue[0] == 'right':
            next_x_position += 1
            if next_x_position >= grid_x_count: #nytt üêç
                next_x_position = 0 #nytt üêç

        elif direction_queue[0] == 'left':
            next_x_position -= 1
            if next_x_position < 0: #nytt üêç
                next_x_position = grid_x_count - 1 #nytt üêç

        elif direction_queue[0] == 'down':
            next_y_position += 1
            if next_y_position >= grid_y_count: #nytt üêç
                next_y_position = 0 #nytt üêç

        elif direction_queue[0] == 'up':
            next_y_position -= 1
            if next_y_position < 0: #nytt üêç
                next_y_position = grid_y_count - 1 #nytt üêç

    # etc.

def draw():
    # Flyttat: grid_x_count = 20
    # Flyttat: grid_y_count = 15
```
‚úèÔ∏è Testk√∂r &ndash; vad h√§nder n√§r ormen n√•r kanten?

![image](https://user-images.githubusercontent.com/4598641/226439789-ce8299ae-1e6c-449b-9dc0-6c64b6124c6f.png)

<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun

# Globala variabler h√§r nedanf√∂r
snake_segments = [
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

direction_queue = ['right']

grid_x_count = 20
grid_y_count = 15

# Funktioner h√§r nedanf√∂r


def update(dt):
    global timer

    timer += dt
    if timer >= 0.15:
        timer = 0
        if len(direction_queue) > 1:
            direction_queue.pop(0)

        next_x_position = snake_segments[0]['x']
        next_y_position = snake_segments[0]['y']

        if direction_queue[0] == 'right':
            next_x_position += 1
            if next_x_position >= grid_x_count:
                next_x_position = 0

        elif direction_queue[0] == 'left':
            next_x_position -= 1
            if next_x_position < 0:
                next_x_position = grid_x_count - 1

        elif direction_queue[0] == 'down':
            next_y_position += 1
            if next_y_position >= grid_y_count:
                next_y_position = 0

        elif direction_queue[0] == 'up':
            next_y_position -= 1
            if next_y_position < 0:
                next_y_position = grid_y_count - 1

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})
        snake_segments.pop()


def on_key_down(key):
    if (key == keys.RIGHT
        and direction_queue[-1] != 'right'
            and direction_queue[-1] != 'left'):
        direction_queue.append('right')

    elif (key == keys.LEFT
          and direction_queue[-1] != 'left'
          and direction_queue[-1] != 'right'):
        direction_queue.append('left')

    elif (key == keys.DOWN
          and direction_queue[-1] != 'down'
          and direction_queue[-1] != 'up'):
        direction_queue.append('down')

    elif (key == keys.UP
          and direction_queue[-1] != 'up'
          and direction_queue[-1] != 'down'):
        direction_queue.append('up')


def draw():
    screen.fill((0, 0, 0))

    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    for segment in snake_segments:
        screen.draw.filled_rect(
            Rect(
                segment['x'] * cell_size, segment['y'] * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=(165, 255, 81)
        )

    # Tillf√§lligt
    for direction_index, direction in enumerate(direction_queue):
        screen.draw.text(
            f"direction_queue[{direction_index}]: {direction}",
            (15, 15 + 15 * direction_index))

# Kod f√∂r att starta appen h√§r nedanf√∂r


pgzrun.go()  # m√•ste vara sista raden
```

</details>


## Rita maten
Maten lagras som ett talpar med X- och Y-koordinater. Maten ritas som en kvadrat.

Slumpmodulen importeras s√• att `random.randint` kan anv√§ndas.

‚úèÔ∏è Uppdatera koden.

```python
import pgzrun
import random #nytt üêç

# etc.

grid_x_count = 20
grid_y_count = 15

food_position = { #nytt üêç
    'x': random.randint(0, grid_x_count - 1), #nytt üêç
    'y': random.randint(0, grid_y_count - 1), #nytt üêç
} #nytt üêç

# etc.

def draw():
    # etc.

    screen.draw.filled_rect( #nytt üêç
        Rect( #nytt üêç
            food_position['x'] * cell_size, food_position['y'] * cell_size, #nytt üêç
            cell_size - 1, cell_size - 1 #nytt üêç
        ), #nytt üêç
        color=(255, 76, 76) #nytt üêç
    ) #nytt üêç 
```
‚úèÔ∏è Testk√∂r &ndash; ritas maten?

![image](https://user-images.githubusercontent.com/4598641/226439842-6fae488e-e72d-494c-bad4-9204c860144a.png)
<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun
import random

# Globala variabler h√§r nedanf√∂r
snake_segments = [
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

direction_queue = ['right']

grid_x_count = 20
grid_y_count = 15

food_position = {
    'x': random.randint(0, grid_x_count - 1),
    'y': random.randint(0, grid_y_count - 1),
}

# Funktioner h√§r nedanf√∂r


def update(dt):
    global timer

    timer += dt
    if timer >= 0.15:
        timer = 0
        if len(direction_queue) > 1:
            direction_queue.pop(0)

        next_x_position = snake_segments[0]['x']
        next_y_position = snake_segments[0]['y']

        if direction_queue[0] == 'right':
            next_x_position += 1
            if next_x_position >= grid_x_count:
                next_x_position = 0

        elif direction_queue[0] == 'left':
            next_x_position -= 1
            if next_x_position < 0:
                next_x_position = grid_x_count - 1

        elif direction_queue[0] == 'down':
            next_y_position += 1
            if next_y_position >= grid_y_count:
                next_y_position = 0

        elif direction_queue[0] == 'up':
            next_y_position -= 1
            if next_y_position < 0:
                next_y_position = grid_y_count - 1

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})
        snake_segments.pop()


def on_key_down(key):
    if (key == keys.RIGHT
        and direction_queue[-1] != 'right'
            and direction_queue[-1] != 'left'):
        direction_queue.append('right')

    elif (key == keys.LEFT
          and direction_queue[-1] != 'left'
          and direction_queue[-1] != 'right'):
        direction_queue.append('left')

    elif (key == keys.DOWN
          and direction_queue[-1] != 'down'
          and direction_queue[-1] != 'up'):
        direction_queue.append('down')

    elif (key == keys.UP
          and direction_queue[-1] != 'up'
          and direction_queue[-1] != 'down'):
        direction_queue.append('up')


def draw():
    screen.fill((0, 0, 0))

    cell_size = 15

    screen.draw.filled_rect(
        Rect(
            0, 0,
            grid_x_count * cell_size, grid_y_count * cell_size
        ),
        color=(70, 70, 70)
    )

    for segment in snake_segments:
        screen.draw.filled_rect(
            Rect(
                segment['x'] * cell_size, segment['y'] * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=(165, 255, 81)
        )

    screen.draw.filled_rect(
        Rect(
            food_position['x'] * cell_size, food_position['y'] * cell_size,
            cell_size - 1, cell_size - 1
        ),
        color=(255, 76, 76)
    )

# Kod f√∂r att starta appen h√§r nedanf√∂r

pgzrun.go()  # m√•ste vara sista raden
```
</details>

## F√∂renkla koden

Koden f√∂r att rita en orms segment och rita maten √§r samma, f√∂rutom f√§rgen. 
Vi g√∂r det till en funktion med f√§rgen som parameter.

‚úèÔ∏è Uppdatera de markerade raderna i `draw`.

```python
def draw():
    screen.fill((0, 0, 0))

    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    def draw_cell(x, y, color): #nytt üêç
        screen.draw.filled_rect( #nytt üêç
            Rect( #nytt üêç
                x * cell_size, y * cell_size, #nytt üêç
                cell_size - 1, cell_size - 1 #nytt üêç
            ), #nytt üêç
            color=color #nytt üêç
        ) #nytt üêç

    for segment in snake_segments:
        draw_cell(segment['x'], segment['y'], color=(165, 255, 81)) #nytt üêç

    draw_cell(food_position['x'], food_position['y'], (255, 76, 76)) #nytt üêç
```
‚úèÔ∏è Testk√∂r &ndash; fungerar koden som innan vi f√∂renklade den?

<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun
import random

# Globala variabler h√§r nedanf√∂r
snake_segments = [
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

direction_queue = ['right']

grid_x_count = 20
grid_y_count = 15

food_position = {
    'x': random.randint(0, grid_x_count - 1),
    'y': random.randint(0, grid_y_count - 1),
}

# Funktioner h√§r nedanf√∂r


def update(dt):
    global timer

    timer += dt
    if timer >= 0.15:
        timer = 0
        if len(direction_queue) > 1:
            direction_queue.pop(0)

        next_x_position = snake_segments[0]['x']
        next_y_position = snake_segments[0]['y']

        if direction_queue[0] == 'right':
            next_x_position += 1
            if next_x_position >= grid_x_count:
                next_x_position = 0

        elif direction_queue[0] == 'left':
            next_x_position -= 1
            if next_x_position < 0:
                next_x_position = grid_x_count - 1

        elif direction_queue[0] == 'down':
            next_y_position += 1
            if next_y_position >= grid_y_count:
                next_y_position = 0

        elif direction_queue[0] == 'up':
            next_y_position -= 1
            if next_y_position < 0:
                next_y_position = grid_y_count - 1

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})
        snake_segments.pop()


def on_key_down(key):
    if (key == keys.RIGHT
        and direction_queue[-1] != 'right'
            and direction_queue[-1] != 'left'):
        direction_queue.append('right')

    elif (key == keys.LEFT
          and direction_queue[-1] != 'left'
          and direction_queue[-1] != 'right'):
        direction_queue.append('left')

    elif (key == keys.DOWN
          and direction_queue[-1] != 'down'
          and direction_queue[-1] != 'up'):
        direction_queue.append('down')

    elif (key == keys.UP
          and direction_queue[-1] != 'up'
          and direction_queue[-1] != 'down'):
        direction_queue.append('up')


def draw():
    screen.fill((0, 0, 0))

    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    def draw_cell(x, y, color):
        screen.draw.filled_rect(
            Rect(
                x * cell_size, y * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=color
        )

    for segment in snake_segments:
        draw_cell(segment['x'], segment['y'], color=(165, 255, 81))

    draw_cell(food_position['x'], food_position['y'], (255, 76, 76))

# Kod f√∂r att starta appen h√§r nedanf√∂r

pgzrun.go()  # m√•ste vara sista raden

```
</details>


## √Ñta maten
    
Om ormens nya huvudposition √§r samma som matens position, tas inte ormens svans bort och maten f√•r en ny slumpm√§ssig position. 
    
P√• s√• vis blir ormen en ruta l√§ngre.

‚úèÔ∏è Uppdatera raderna i `update()`.

  ```python
def update(dt):
    global timer, food_position #√§ndrat üêç

    timer += dt
    if timer >= 0.15:
        timer = 0

        if len(direction_queue) > 1:
            direction_queue.pop(0)

        next_x_position = snake_segments[0]['x']
        next_y_position = snake_segments[0]['y']

        if direction_queue[0] == 'right':
            next_x_position += 1
            if next_x_position >= grid_x_count:
                next_x_position = 0

        elif direction_queue[0] == 'left':
            next_x_position -= 1
            if next_x_position < 0:
                next_x_position = grid_x_count - 1

        elif direction_queue[0] == 'down':
            next_y_position += 1
            if next_y_position >= grid_y_count:
                next_y_position = 0

        elif direction_queue[0] == 'up':
            next_y_position -= 1
            if next_y_position < 0:
                next_y_position = grid_y_count - 1

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})

        if (snake_segments[0]['x'] == food_position['x'] #nytt üêç
        and snake_segments[0]['y'] == food_position['y']): #nytt üêç
            food_position = { #nytt üêç
                'x': random.randint(0, grid_x_count - 1), #nytt üêç
                'y': random.randint(0, grid_y_count - 1), #nytt üêç
            } #nytt üêç
        else: #nytt üêç
            snake_segments.pop() #dra in raden üêç
```
                                   
‚úèÔ∏è Testk√∂r &ndash; vad h√§nder n√§r ormen √§ter?

<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun
import random

# Globala variabler h√§r nedanf√∂r
snake_segments = [
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

direction_queue = ['right']

grid_x_count = 20
grid_y_count = 15

food_position = {
    'x': random.randint(0, grid_x_count - 1),
    'y': random.randint(0, grid_y_count - 1),
}

# Funktioner h√§r nedanf√∂r


def update(dt):
    global timer, food_position

    timer += dt
    if timer >= 0.15:
        timer = 0
        if len(direction_queue) > 1:
            direction_queue.pop(0)

        next_x_position = snake_segments[0]['x']
        next_y_position = snake_segments[0]['y']

        if direction_queue[0] == 'right':
            next_x_position += 1
            if next_x_position >= grid_x_count:
                next_x_position = 0

        elif direction_queue[0] == 'left':
            next_x_position -= 1
            if next_x_position < 0:
                next_x_position = grid_x_count - 1

        elif direction_queue[0] == 'down':
            next_y_position += 1
            if next_y_position >= grid_y_count:
                next_y_position = 0

        elif direction_queue[0] == 'up':
            next_y_position -= 1
            if next_y_position < 0:
                next_y_position = grid_y_count - 1

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})

        if (snake_segments[0]['x'] == food_position['x']
                and snake_segments[0]['y'] == food_position['y']):
            food_position = {
                'x': random.randint(0, grid_x_count - 1),
                'y': random.randint(0, grid_y_count - 1),
            }
        else:
            snake_segments.pop()


def on_key_down(key):
    if (key == keys.RIGHT
        and direction_queue[-1] != 'right'
            and direction_queue[-1] != 'left'):
        direction_queue.append('right')

    elif (key == keys.LEFT
          and direction_queue[-1] != 'left'
          and direction_queue[-1] != 'right'):
        direction_queue.append('left')

    elif (key == keys.DOWN
          and direction_queue[-1] != 'down'
          and direction_queue[-1] != 'up'):
        direction_queue.append('down')

    elif (key == keys.UP
          and direction_queue[-1] != 'up'
          and direction_queue[-1] != 'down'):
        direction_queue.append('up')


def draw():
    screen.fill((0, 0, 0))

    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    def draw_cell(x, y, color):
        screen.draw.filled_rect(
            Rect(
                x * cell_size, y * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=color
        )

    for segment in snake_segments:
        draw_cell(segment['x'], segment['y'], color=(165, 255, 81))

    draw_cell(food_position['x'], food_position['y'], (255, 76, 76))

# Kod f√∂r att starta appen h√§r nedanf√∂r

pgzrun.go()  # m√•ste vara sista raden
```

</details>

## F√∂renkla koden
Koden f√∂r att l√§gga maten p√• en slumpm√§ssig position beh√∂vs p√• fler st√§llen. Vi g√∂r en funktion f√∂r det.
    
‚úèÔ∏è Uppdatera koden.

```python
def move_food(): #nytt üêç
    global food_position #nytt üêç

    food_position = { #flyttat üêç
        'x': random.randint(0, grid_x_count - 1), #flyttat üêç
        'y': random.randint(0, grid_y_count - 1) #flyttat üêç
    } #flyttat üêç

def update(dt):
    # etc.

        if (snake_segments[0]['x'] == food_position['x']
        and snake_segments[0]['y'] == food_position['y']):
            move_food() #nytt üêç
        else:
            snake_segments.pop()

    # etc.
    
# Kod f√∂r att starta appen h√§r nedanf√∂r
move_food() #nytt üêç

pgzrun.go()  # m√•ste vara sista raden
```
‚úèÔ∏è Testk√∂r &ndash; fungerar koden lika bra som innan?

<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun
import random

# Globala variabler h√§r nedanf√∂r
snake_segments = [
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

direction_queue = ['right']

grid_x_count = 20
grid_y_count = 15

food_position = {
    'x': random.randint(0, grid_x_count - 1),
    'y': random.randint(0, grid_y_count - 1),
}

# Funktioner h√§r nedanf√∂r
def move_food():
    global food_position

    food_position = {
        'x': random.randint(0, grid_x_count - 1),
        'y': random.randint(0, grid_y_count - 1)
    }

def update(dt):
    global timer, food_position

    timer += dt
    if timer >= 0.15:
        timer = 0
        if len(direction_queue) > 1:
            direction_queue.pop(0)

        next_x_position = snake_segments[0]['x']
        next_y_position = snake_segments[0]['y']

        if direction_queue[0] == 'right':
            next_x_position += 1
            if next_x_position >= grid_x_count:
                next_x_position = 0

        elif direction_queue[0] == 'left':
            next_x_position -= 1
            if next_x_position < 0:
                next_x_position = grid_x_count - 1

        elif direction_queue[0] == 'down':
            next_y_position += 1
            if next_y_position >= grid_y_count:
                next_y_position = 0

        elif direction_queue[0] == 'up':
            next_y_position -= 1
            if next_y_position < 0:
                next_y_position = grid_y_count - 1

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})

        if (snake_segments[0]['x'] == food_position['x']
                and snake_segments[0]['y'] == food_position['y']):
            move_food()
        else:
            snake_segments.pop()


def on_key_down(key):
    if (key == keys.RIGHT
        and direction_queue[-1] != 'right'
            and direction_queue[-1] != 'left'):
        direction_queue.append('right')

    elif (key == keys.LEFT
          and direction_queue[-1] != 'left'
          and direction_queue[-1] != 'right'):
        direction_queue.append('left')

    elif (key == keys.DOWN
          and direction_queue[-1] != 'down'
          and direction_queue[-1] != 'up'):
        direction_queue.append('down')

    elif (key == keys.UP
          and direction_queue[-1] != 'up'
          and direction_queue[-1] != 'down'):
        direction_queue.append('up')


def draw():
    screen.fill((0, 0, 0))

    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    def draw_cell(x, y, color):
        screen.draw.filled_rect(
            Rect(
                x * cell_size, y * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=color
        )

    for segment in snake_segments:
        draw_cell(segment['x'], segment['y'], color=(165, 255, 81))

    draw_cell(food_position['x'], food_position['y'], (255, 76, 76))

# Kod f√∂r att starta appen h√§r nedanf√∂r
move_food()

pgzrun.go()  # m√•ste vara sista raden

```
</details>

## Flytta maten till en ledig ruta
    
Ist√§llet f√∂r att flytta maten till en slumpm√§ssig plats, flyttar den till en plats d√§r ormen inte √§r just nu.
    
Alla positioner i rutn√§tet loopas igenom. F√∂r varje rutn√§tsposition loopar vi igenom alla ormens segment.
Om inga ormsegment √§r p√• en viss rutn√§tsposition, l√§ggs den positionen till i en lista √∂ver m√∂jliga matpositioner.
N√§sta matposition v√§ljs sen slumpm√§ssigt fr√•n den listan.

‚úèÔ∏è Uppdatera kodraderna i `move_food`. 

```python
def move_food():
    global food_position

    possible_food_positions = [] #nytt üêç

    for food_x in range(grid_x_count): #nytt üêç
        for food_y in range(grid_y_count): #nytt üêç
            possible = True #nytt üêç

            for segment in snake_segments: #nytt üêç
                if food_x == segment['x'] and food_y == segment['y']: #nytt üêç
                    possible = False #nytt üêç

            if possible: #nytt üêç
                possible_food_positions.append({'x': food_x, 'y': food_y}) #nytt üêç

    food_position = random.choice(possible_food_positions) #nytt üêç
```

‚úèÔ∏è Testk√∂r &ndash; vad h√§nder n√§r ormen √§ter?

<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun
import random

# Globala variabler h√§r nedanf√∂r
snake_segments = [
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

direction_queue = ['right']

grid_x_count = 20
grid_y_count = 15

# Funktioner h√§r nedanf√∂r


def move_food():
    global food_position

    possible_food_positions = []

    for food_x in range(grid_x_count):
        for food_y in range(grid_y_count):
            possible = True

            for segment in snake_segments:
                if food_x == segment['x'] and food_y == segment['y']:
                    possible = False

            if possible:
                possible_food_positions.append({'x': food_x, 'y': food_y})

    food_position = random.choice(possible_food_positions)


def update(dt):
    global timer, food_position

    timer += dt
    if timer >= 0.15:
        timer = 0
        if len(direction_queue) > 1:
            direction_queue.pop(0)

        next_x_position = snake_segments[0]['x']
        next_y_position = snake_segments[0]['y']

        if direction_queue[0] == 'right':
            next_x_position += 1
            if next_x_position >= grid_x_count:
                next_x_position = 0

        elif direction_queue[0] == 'left':
            next_x_position -= 1
            if next_x_position < 0:
                next_x_position = grid_x_count - 1

        elif direction_queue[0] == 'down':
            next_y_position += 1
            if next_y_position >= grid_y_count:
                next_y_position = 0

        elif direction_queue[0] == 'up':
            next_y_position -= 1
            if next_y_position < 0:
                next_y_position = grid_y_count - 1

        snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})

        if (snake_segments[0]['x'] == food_position['x']
                and snake_segments[0]['y'] == food_position['y']):
            move_food()
        else:
            snake_segments.pop()


def on_key_down(key):
    if (key == keys.RIGHT
        and direction_queue[-1] != 'right'
            and direction_queue[-1] != 'left'):
        direction_queue.append('right')

    elif (key == keys.LEFT
          and direction_queue[-1] != 'left'
          and direction_queue[-1] != 'right'):
        direction_queue.append('left')

    elif (key == keys.DOWN
          and direction_queue[-1] != 'down'
          and direction_queue[-1] != 'up'):
        direction_queue.append('down')

    elif (key == keys.UP
          and direction_queue[-1] != 'up'
          and direction_queue[-1] != 'down'):
        direction_queue.append('up')


def draw():
    screen.fill((0, 0, 0))

    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    def draw_cell(x, y, color):
        screen.draw.filled_rect(
            Rect(
                x * cell_size, y * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=color
        )

    for segment in snake_segments:
        draw_cell(segment['x'], segment['y'], color=(165, 255, 81))

    draw_cell(food_position['x'], food_position['y'], (255, 76, 76))


# Kod f√∂r att starta appen h√§r nedanf√∂r
move_food()

pgzrun.go()  # m√•ste vara sista raden
```
</details>

## Game over
    
Ormens segment loopas igenom. Om n√•got av dem &ndash; f√∂rutom det sista &ndash; √§r i samma position som ormens nya huvudposition, s√• har ormen kraschat in i sig sj√§lv.
>Det sista segmentet p√• ormen ska inte kollas eftersom det kommer att tas bort inom samma tick.

F√∂r n√§rvarande skrivs `collision` ut n√§r ormen kraschar in i sig sj√§lv. 

‚úèÔ∏è Uppdatera i funktionen `update`.
  
```python
def update(dt):
    # etc.
        elif direction_queue[0] == 'up':
            next_y_position -= 1
            if next_y_position < 0:
                next_y_position = grid_y_count - 1    
    
        can_move = True #nytt üêç

        for segment in snake_segments[:-1]: #nytt üêç
            if (next_x_position == segment['x'] #nytt üêç
            and next_y_position == segment['y']): #nytt üêç
                can_move = False #nytt üêç

        if can_move: #nytt üêç
            snake_segments.insert(0, {'x': next_x_position, 'y': next_y_position})

            if (snake_segments[0]['x'] == food_position['x']
            and snake_segments[0]['y'] == food_position['y']):
                move_food()
            else:
                snake_segments.pop()
        else: #nytt üêç
            print('collision') #nytt üêç    
```
‚úèÔ∏è Testk√∂r &ndash; vad h√§nder n√§r ormen kraschar in sig sj√§lv? Kolla i det svarta terminalf√∂nstret (Console) nere till h√∂ger.
                                   
<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun
import random

# Globala variabler h√§r nedanf√∂r
snake_segments = [
    {'x': 2, 'y': 0},
    {'x': 1, 'y': 0},
    {'x': 0, 'y': 0},
]

timer = 0

direction_queue = ['right']

grid_x_count = 20
grid_y_count = 15

# Funktioner h√§r nedanf√∂r


def move_food():
    global food_position

    possible_food_positions = []

    for food_x in range(grid_x_count):
        for food_y in range(grid_y_count):
            possible = True

            for segment in snake_segments:
                if food_x == segment['x'] and food_y == segment['y']:
                    possible = False

            if possible:
                possible_food_positions.append({'x': food_x, 'y': food_y})

    food_position = random.choice(possible_food_positions)


def update(dt):
    global timer, food_position

    timer += dt
    if timer >= 0.15:
        timer = 0
        if len(direction_queue) > 1:
            direction_queue.pop(0)

        next_x_position = snake_segments[0]['x']
        next_y_position = snake_segments[0]['y']

        if direction_queue[0] == 'right':
            next_x_position += 1
            if next_x_position >= grid_x_count:
                next_x_position = 0

        elif direction_queue[0] == 'left':
            next_x_position -= 1
            if next_x_position < 0:
                next_x_position = grid_x_count - 1

        elif direction_queue[0] == 'down':
            next_y_position += 1
            if next_y_position >= grid_y_count:
                next_y_position = 0

        elif direction_queue[0] == 'up':
            next_y_position -= 1
            if next_y_position < 0:
                next_y_position = grid_y_count - 1

        can_move = True

        for segment in snake_segments[:-1]:
            if (next_x_position == segment['x']
                    and next_y_position == segment['y']):
                can_move = False

        if can_move:
            snake_segments.insert(
                0, {'x': next_x_position, 'y': next_y_position})

            if (snake_segments[0]['x'] == food_position['x']
                    and snake_segments[0]['y'] == food_position['y']):
                move_food()
            else:
                snake_segments.pop()
        else:
            print('collision')


def on_key_down(key):
    if (key == keys.RIGHT
        and direction_queue[-1] != 'right'
            and direction_queue[-1] != 'left'):
        direction_queue.append('right')

    elif (key == keys.LEFT
          and direction_queue[-1] != 'left'
          and direction_queue[-1] != 'right'):
        direction_queue.append('left')

    elif (key == keys.DOWN
          and direction_queue[-1] != 'down'
          and direction_queue[-1] != 'up'):
        direction_queue.append('down')

    elif (key == keys.UP
          and direction_queue[-1] != 'up'
          and direction_queue[-1] != 'down'):
        direction_queue.append('up')


def draw():
    screen.fill((0, 0, 0))

    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    def draw_cell(x, y, color):
        screen.draw.filled_rect(
            Rect(
                x * cell_size, y * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=color
        )

    for segment in snake_segments:
        draw_cell(segment['x'], segment['y'], color=(165, 255, 81))

    draw_cell(food_position['x'], food_position['y'], (255, 76, 76))


# Kod f√∂r att starta appen h√§r nedanf√∂r
move_food()

pgzrun.go()  # m√•ste vara sista raden
```
</details>

## √Öterst√§lla spelet
Vi g√∂r en funktion som st√§ller in spelets startl√§ge.

Funktionen anropas innan spelet b√∂rjar och n√§r ormen kraschar.

‚úèÔ∏è L√§gg till funktionen `reset()` och g√∂r de andra sm√•√§ndringarna p√• markerade rader.

```python
grid_x_count = 20
grid_y_count = 15

def move_food():
    # etc.

def reset():
    global timer, direction_queue, snake_segments #nytt üêç

    timer = 0
    direction_queue = ['right']
    snake_segments = [
        {'x': 2, 'y': 0},
        {'x': 1, 'y': 0},
        {'x': 0, 'y': 0},
    ]
    move_food()

def update(dt):
    # etc.

        if can_move:
            # etc.
        else:
            reset() #nytt üêç

# etc.

# Kod f√∂r att starta appen h√§r nedanf√∂r
reset() #√§ndrat üêç

pgzrun.go()  # m√•ste vara sista raden
    
```

‚úèÔ∏è Testk√∂r &ndash; vad h√§nder n√§r ormen kraschar?

<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun
import random

# Globala variabler h√§r nedanf√∂r
timer = 0

direction_queue = ['right']

grid_x_count = 20
grid_y_count = 15


# Funktioner h√§r nedanf√∂r


def move_food():
    global food_position

    possible_food_positions = []

    for food_x in range(grid_x_count):
        for food_y in range(grid_y_count):
            possible = True

            for segment in snake_segments:
                if food_x == segment['x'] and food_y == segment['y']:
                    possible = False

            if possible:
                possible_food_positions.append({'x': food_x, 'y': food_y})

    food_position = random.choice(possible_food_positions)


def reset():
    global timer, direction_queue, snake_segments  # nytt üêç

    timer = 0
    direction_queue = ['right']
    snake_segments = [
        {'x': 2, 'y': 0},
        {'x': 1, 'y': 0},
        {'x': 0, 'y': 0},
    ]
    move_food()


def update(dt):
    global timer, food_position

    timer += dt
    if timer >= 0.15:
        timer = 0
        if len(direction_queue) > 1:
            direction_queue.pop(0)

        next_x_position = snake_segments[0]['x']
        next_y_position = snake_segments[0]['y']

        if direction_queue[0] == 'right':
            next_x_position += 1
            if next_x_position >= grid_x_count:
                next_x_position = 0

        elif direction_queue[0] == 'left':
            next_x_position -= 1
            if next_x_position < 0:
                next_x_position = grid_x_count - 1

        elif direction_queue[0] == 'down':
            next_y_position += 1
            if next_y_position >= grid_y_count:
                next_y_position = 0

        elif direction_queue[0] == 'up':
            next_y_position -= 1
            if next_y_position < 0:
                next_y_position = grid_y_count - 1

        can_move = True

        for segment in snake_segments[:-1]:
            if (next_x_position == segment['x']
                    and next_y_position == segment['y']):
                can_move = False

        if can_move:
            snake_segments.insert(
                0, {'x': next_x_position, 'y': next_y_position})

            if (snake_segments[0]['x'] == food_position['x']
                    and snake_segments[0]['y'] == food_position['y']):
                move_food()
            else:
                snake_segments.pop()
        else:
            reset()


def on_key_down(key):
    if (key == keys.RIGHT
        and direction_queue[-1] != 'right'
            and direction_queue[-1] != 'left'):
        direction_queue.append('right')

    elif (key == keys.LEFT
          and direction_queue[-1] != 'left'
          and direction_queue[-1] != 'right'):
        direction_queue.append('left')

    elif (key == keys.DOWN
          and direction_queue[-1] != 'down'
          and direction_queue[-1] != 'up'):
        direction_queue.append('down')

    elif (key == keys.UP
          and direction_queue[-1] != 'up'
          and direction_queue[-1] != 'down'):
        direction_queue.append('up')


def draw():
    screen.fill((0, 0, 0))

    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    def draw_cell(x, y, color):
        screen.draw.filled_rect(
            Rect(
                x * cell_size, y * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=color
        )

    for segment in snake_segments:
        draw_cell(segment['x'], segment['y'], color=(165, 255, 81))

    draw_cell(food_position['x'], food_position['y'], (255, 76, 76))


# Kod f√∂r att starta appen h√§r nedanf√∂r
reset()

pgzrun.go()  # m√•ste vara sista raden

```
</details>

## Pausa efter att ormen har kraschat
    
En variabel anv√§nds f√∂r att lagra om ormen √§r vid liv eller inte. Om den √§r `False` (falskt) s√• har ormen kraschat.

Om ormen √§r d√∂d, v√§ntar timern i 2 sekunder innan den anropar `reset()` f√∂r att starta om spelet.
    
‚úèÔ∏è Uppdatera koden p√• de markerade raderna.

```python
def reset():
    # etc.
    global snake_alive #nytt üêç

    # etc.
    snake_alive = True #nytt üêç

def update(dt):
    global timer, food_position, snake_alive #√§ndrat üêç

    timer += dt

    if snake_alive: #nytt
        if timer >= 0.15:
            timer = 0

            # etc.

            if can_move:
                # etc.
            else:
                snake_alive = False #nytt üêç

    elif timer >= 2: #nytt üêç
        reset() #nytt üêç
```
‚úèÔ∏è Testk√∂r &ndash; vad h√§nder n√§r ormen kraschar?

<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun
import random

# Globala variabler h√§r nedanf√∂r
timer = 0

direction_queue = ['right']

grid_x_count = 20
grid_y_count = 15

    
# Funktioner h√§r nedanf√∂r

def move_food():
    global food_position

    possible_food_positions = []

    for food_x in range(grid_x_count):
        for food_y in range(grid_y_count):
            possible = True

            for segment in snake_segments:
                if food_x == segment['x'] and food_y == segment['y']:
                    possible = False

            if possible:
                possible_food_positions.append({'x': food_x, 'y': food_y})

    food_position = random.choice(possible_food_positions)


def reset():
    global timer, direction_queue, snake_segments, snake_alive  # nytt üêç

    timer = 0
    direction_queue = ['right']
    snake_segments = [
        {'x': 2, 'y': 0},
        {'x': 1, 'y': 0},
        {'x': 0, 'y': 0},
    ]
    move_food()
    snake_alive = True


def update(dt):
    global timer, food_position, snake_alive

    timer += dt
    if snake_alive:
        if timer >= 0.15:
            timer = 0
            if len(direction_queue) > 1:
                direction_queue.pop(0)

            next_x_position = snake_segments[0]['x']
            next_y_position = snake_segments[0]['y']

            if direction_queue[0] == 'right':
                next_x_position += 1
                if next_x_position >= grid_x_count:
                    next_x_position = 0

            elif direction_queue[0] == 'left':
                next_x_position -= 1
                if next_x_position < 0:
                    next_x_position = grid_x_count - 1

            elif direction_queue[0] == 'down':
                next_y_position += 1
                if next_y_position >= grid_y_count:
                    next_y_position = 0

            elif direction_queue[0] == 'up':
                next_y_position -= 1
                if next_y_position < 0:
                    next_y_position = grid_y_count - 1

            can_move = True

            for segment in snake_segments[:-1]:
                if (next_x_position == segment['x']
                        and next_y_position == segment['y']):
                    can_move = False

            if can_move:
                snake_segments.insert(
                    0, {'x': next_x_position, 'y': next_y_position})

                if (snake_segments[0]['x'] == food_position['x']
                        and snake_segments[0]['y'] == food_position['y']):
                    move_food()
                else:
                    snake_segments.pop()
            else:
                snake_alive = False
    elif timer >= 2:
        reset()


def on_key_down(key):
    if (key == keys.RIGHT
        and direction_queue[-1] != 'right'
            and direction_queue[-1] != 'left'):
        direction_queue.append('right')

    elif (key == keys.LEFT
          and direction_queue[-1] != 'left'
          and direction_queue[-1] != 'right'):
        direction_queue.append('left')

    elif (key == keys.DOWN
          and direction_queue[-1] != 'down'
          and direction_queue[-1] != 'up'):
        direction_queue.append('down')

    elif (key == keys.UP
          and direction_queue[-1] != 'up'
          and direction_queue[-1] != 'down'):
        direction_queue.append('up')


def draw():
    screen.fill((0, 0, 0))

    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    def draw_cell(x, y, color):
        screen.draw.filled_rect(
            Rect(
                x * cell_size, y * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=color
        )

    for segment in snake_segments:
        draw_cell(segment['x'], segment['y'], color=(165, 255, 81))

    draw_cell(food_position['x'], food_position['y'], (255, 76, 76))


# Kod f√∂r att starta appen h√§r nedanf√∂r
reset()

pgzrun.go()  # m√•ste vara sista raden
```

</details>

## √Ñndra ormens f√§rg n√§r den √§r d√∂d

Ormens f√§rg √§ndras beroende p√• om den √§r vid liv eller inte.

‚úèÔ∏è Uppdatera kodraderna i `draw()`.

```python
def draw():
    # etc.

    for segment in snake_segments:
        color = (165, 255, 81)
        if not snake_alive:
            color = (140, 140, 140)
        draw_cell(segment['x'], segment['y'], color)

    # etc.    
```
‚úèÔ∏è Testk√∂r &ndash; vad h√§nder n√§r ormen d√∂r?


![image](https://user-images.githubusercontent.com/4598641/226440133-a580b309-3b49-400d-ab5b-97c545c75ecd.png)
<details>
    <summary>üìù S√• h√§r kan koden se ut nu</summary>

```python
import pgzrun
import random

# Globala variabler h√§r nedanf√∂r
timer = 0

direction_queue = ['right']

grid_x_count = 20
grid_y_count = 15

# Funktioner h√§r nedanf√∂r

def move_food():
    global food_position

    possible_food_positions = []

    for food_x in range(grid_x_count):
        for food_y in range(grid_y_count):
            possible = True

            for segment in snake_segments:
                if food_x == segment['x'] and food_y == segment['y']:
                    possible = False

            if possible:
                possible_food_positions.append({'x': food_x, 'y': food_y})

    food_position = random.choice(possible_food_positions)


def reset():
    global timer, direction_queue, snake_segments, snake_alive  # nytt üêç

    timer = 0
    direction_queue = ['right']
    snake_segments = [
        {'x': 2, 'y': 0},
        {'x': 1, 'y': 0},
        {'x': 0, 'y': 0},
    ]
    move_food()
    snake_alive = True


def update(dt):
    global timer, food_position, snake_alive

    timer += dt
    if snake_alive:
        if timer >= 0.15:
            timer = 0
            if len(direction_queue) > 1:
                direction_queue.pop(0)

            next_x_position = snake_segments[0]['x']
            next_y_position = snake_segments[0]['y']

            if direction_queue[0] == 'right':
                next_x_position += 1
                if next_x_position >= grid_x_count:
                    next_x_position = 0

            elif direction_queue[0] == 'left':
                next_x_position -= 1
                if next_x_position < 0:
                    next_x_position = grid_x_count - 1

            elif direction_queue[0] == 'down':
                next_y_position += 1
                if next_y_position >= grid_y_count:
                    next_y_position = 0

            elif direction_queue[0] == 'up':
                next_y_position -= 1
                if next_y_position < 0:
                    next_y_position = grid_y_count - 1

            can_move = True

            for segment in snake_segments[:-1]:
                if (next_x_position == segment['x']
                        and next_y_position == segment['y']):
                    can_move = False

            if can_move:
                snake_segments.insert(
                    0, {'x': next_x_position, 'y': next_y_position})

                if (snake_segments[0]['x'] == food_position['x']
                        and snake_segments[0]['y'] == food_position['y']):
                    move_food()
                else:
                    snake_segments.pop()
            else:
                snake_alive = False
    elif timer >= 2:
        reset()


def on_key_down(key):
    if (key == keys.RIGHT
        and direction_queue[-1] != 'right'
            and direction_queue[-1] != 'left'):
        direction_queue.append('right')

    elif (key == keys.LEFT
          and direction_queue[-1] != 'left'
          and direction_queue[-1] != 'right'):
        direction_queue.append('left')

    elif (key == keys.DOWN
          and direction_queue[-1] != 'down'
          and direction_queue[-1] != 'up'):
        direction_queue.append('down')

    elif (key == keys.UP
          and direction_queue[-1] != 'up'
          and direction_queue[-1] != 'down'):
        direction_queue.append('up')


def draw():
    screen.fill((0, 0, 0))

    cell_size = 15

    screen.draw.filled_rect(
        Rect(0, 0, grid_x_count * cell_size, grid_y_count * cell_size),
        color=(70, 70, 70),
    )

    def draw_cell(x, y, color):
        screen.draw.filled_rect(
            Rect(
                x * cell_size, y * cell_size,
                cell_size - 1, cell_size - 1
            ),
            color=color
        )

    for segment in snake_segments:
        color = (165, 255, 81)
        if not snake_alive:
            color = (140, 140, 140)
        draw_cell(segment['x'], segment['y'], color)

    draw_cell(food_position['x'], food_position['y'], (255, 76, 76))

# Kod f√∂r att starta appen h√§r nedanf√∂r
reset()

pgzrun.go()  # m√•ste vara sista raden
```
</details>

# Uppgifter
## 1.  Vad tyckte du var sv√•rt med kodningen? 
Ge ett par exempel d√§r du/ni k√∂rde fast eller hade sv√•rt att f√∂rst√• koden.

## 2. G√∂r spelet √§nnu b√§ttre
Pr√∂va att g√∂ra n√•gra √§ndringar eller till√§gg. Det kan vara en po√§ngr√§knare f√∂r ormens l√§ngd, high score, roligare game over, en introsk√§rm eller n√•got annat som √§r standard i den h√§r typen av spel.
- Beskriv kort vad f√∂r√§ndringen √§r och hur den ska fungera.
- Beskriv hur du fick √§ndra koden f√∂r att g√∂ra √§ndringen. Gl√∂m inte kodexempel.
- Om det inte gick att genomf√∂ra, f√∂rklara med n√•gra meningar vad du f√∂rs√∂kte och vad som h√§nde. Gl√∂m inte kodexempel.

## 3. Be n√•gon annan att testa ditt projekt
- Be om konstruktiv kritik p√• spelet. Skriv ner
- Be om konstruktiv kritik p√• koden. Skriv ner
- Har du n√•got tips att f√∂r n√•gon som inte har gjort det h√§r projektet innan? Skriv ner
  
# K√§llor

https://simplegametutorials.github.io/pygamezero/snake/

https://web.archive.org/web/20140820192218/http://www.realtid.se/ArticlePages/200603/01/20060301132710_Realtid437/20060301132710_Realtid437.dbp.asp?Action=Print
